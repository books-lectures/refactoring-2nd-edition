# CH02. 리팩터링 원칙

# 리팩터링 원칙

```
💡 난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요
- 켄트 벡
```

## 1. 리팩터링 정의

- 소프트웨어의 `겉보기 동작은 그대로 유지`한채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 행위, 기법
- 코드를 정리하거나 구조를 바꾸는 모든 작업을 `재구성` 이라는 포괄적인 용어로 표현하고, 리팩터링은 재구성 중 특수한 하나의 형태이다(특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다)
- 리팩터링 전과 후는 똑같이 동작하지만, `함수 추출하기`를 거치면 콜스택이 달라져서 성능이 변할 수 있다
- 리팩터링은 성능최적화와 비슷하지만 목적이 다르다. 리팩터링(가독성), 성능최적화(속도개선)

## 2. 두개의 모자(기능추가 or 리팩터링)

- 소프트웨어 개발시 목적을 정확히 구분한 뒤 해당 목적에만 맞는 일에 집중한다
- 짧은 시간이라고 하더라도, 현재 쓰고있는모자(목적)이 무엇인지와 그에따른 미묘한 작업방식의 차이를 분명하게 인식해야 한다

## 3. 리팩터링하는 이유

1. 소프트웨어 설계가 좋아진다
- 리팩터링 하지 않으면 소프트웨어의 내부설계(아키텍쳐)를 이해하지 못한채 단기 목표만을 위해 코드를 수정하다보면 기반구조가 무너지고, 코드가 썩기 쉽다
- 비슷한 일을 하는 중복되는 코드가 많으면, 한부분만 바꿔서는 예상대로 작동하지 않는다
- 중복되는 코드를 줄이면, 수정하는데 드는 노력이 줄어든다
2. 소프트웨어를 이해하기 쉬워진다
- 소스코드는 컴퓨터가 처리하지만, 읽는건 미래의 나와 동료이다. 코드를 이해하기 쉽게 만들려면 리팩터링을 통해 목적이 잘 드러나게, 의도를 명확하게 전달해야 한다.
3. 버그를 쉽게 찾을 수 있다
- 코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다.
- 프로그램의 구조를 명확하게 다듬으면 버그가 명확하게 보이게 된다
4. 프로그래밍 속도를 높일 수 있다
- 내부설계가 잘 된 소프트웨어는 모듈화가 잘되어있어 기능 추가와 디버깅에 유리하다
- 리팩터링 되지 않은 코드에 새로운 기능을 추가하게되면 버그가 발생하는 일이 잦고, 해결하는데 필요한 시간도 많아진다

## 4. 언제 리팩터링해야 할까?

```
[3의 법칙]

1. 처음에는 그냥 한다
2. 비슷한 일을 두번째로 하면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다
3. 비슷한 일을 세번째 하게 되면 리팩터링 한다

- 저자는 거의 한시간 간격으로 리팩터링 한다고 한다
```

### 준비를 위한 리팩터링: 기능을 추가하기 쉽게 만들기

기능을 추가하기 직전에 현재코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기 훨씬 쉬워질 만한 부분을 찾는다. 중복코드를 발견하면 `함수 매개변수화하기` 를 적용한다. 이후 함수에 필요한 매개변수를 지정해서 호출하기만 하면 된다.

버그잡을때도 마찬가지로 같은 코드를 하나로 합친 후 버그를 수정하는게 좋다

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

세부사항들은 점점 잊혀지게 된다. 이해한 바를 리팩터링을 통해 코드에 녹여내면 이해한 바를 더 오래 보존할 수 있고, 동료들도 이해하기 쉬워진다

### 쓰레기 줍기 리팩터링

캠핑규칙이 제안하듯, 항상 처음 봤을 때보다 깔끔하게 정리하고 떠나자. 코드중에 중복되거나 로직이 쓸데없이 복잡한 부분은 정도에 따라 업무의 전후에 처리한다. 이것이 이해를 위한 리팩터링의 변형인 `쓰레기 줍기 리팩터링` 이다

### 계획된 리팩터링과 수시로 하는 리팩터링

- 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니기 때문에, 기회가 될 때 진행한다.
- 저자는 리팩터링 시간을 따로 잡아두지 않고 다른 일을 하는 중에 처리한다고 한다. 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.
- 소프트웨어에 기능이 추가될 때, 뛰어난 개발자는 새 기능을 추가하기 쉽도록 기존 코드를 수정한다. 그렇기 때문에 `새로 작성해 넣는 코드`보다 `기존코드의 수정량`이 큰 경우가 대체로 많다.

### 오래 걸리는 리팩터링

리팩터링은 몇주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다. 팀 전체가 몇주에 걸쳐 리팩터링에 매달리는것을 저자는 회의적으로 본다.

### 코드 리뷰에 리팩터링 활용하기

코드리뷰는 개발팀 전체에 노하우와 지식을 전파하는데 좋고, 다른 사람의 아이디어를 얻을 수 있고 결과적으로 서로의 기여가 일을 더욱 편하게 만들어 준다.

PR방식(작성자 없이 검토하는 방식)은 그리 효과적이지 않다. 코드 작성자가 참석해야 맥락을 설명해 줄 수 있고, 작성자도 리뷰어의 변경 의도를 제대로 이해할 수 있으므로 참석자가 같이 참석하는것이 좋다. 저자가 경험한 가장 좋은 방법은 `짝 프로그래밍`이라고 한다

### 관리자에게는 뭐라고 말해야 할까?

관리자와 고객이 기술에 정통하고 설계 지구력 가설도 잘 이해하고 있다면, 리팩터링의 필요성을 쉽게 설명할 수 있다. 하지만 그렇지 않다면 `리팩터링 한다고 말하지 말라`

프로 개발자의 역할은 효과적인 소프트웨어를 빠르게 만드는것 → 리팩터링은 소프트웨어를 빠르게 만드는데 아주 효과적 → 관리자가 원하는 바(빠르게 완성)를 리팩터링을 통해 실현한다 

### 리팩터링하지 말아야 할 때

지저분한 코드를 발견해도, `굳이 수정할 필요가 없다면` 리팩터링 하지 않는다

필요에 의해 코드를 작성하게 되는시점에, 코드에 대한 이해를 바탕으로 리팩터링해야 한다

## 5. 리팩터링 시 고려할 문제

리팩터링에 딸려오는 문제도 엄연히 있기 때문에, 문제가 언제 발생하고 어떻게 대처해야 할지를 반드시 알고 있어야 한다

### 새 기능 개발 속도 저하

`준비를 위한 리팩터링`을 하면 변경을 훨씬 쉽게 할 수 있다. 그렇기 때문에 `새 기능을 구현해넣기 편해질것같은` 리팩터링은 주저하지 않고 한다.

이외의 상황에는 굳이 건드리지 않거나 개인의 경험으로 리팩터링을 할지 말지 결정한다.

- 리팩터링의 본질은 경제적인 이유로 하는것이다. 코드를 예쁘게 꾸미는데 있지 않다
- 리팩터링은 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다

위 내용을 명확히 이해하는 개발자, 관리자, 고객이 많아질수록 소프트웨어의 ‘좋은 설계’를 더 많이 볼 수 있다

### 코드 소유권

코드의 소유권을 팀에 두는것이 좋다.

리팩터링을 하다보면 시스템의 다른 부분과 연동되는 부분이 많기 때문에, 코드소유권이 없다면 제한적인 리팩터링을 할 수 밖에 없다. 기존함수를 유지하며 새로만드는 함수에서 기존함수를 호출하는 방식으로 리팩터링 할 수 있지만,인터페이스가 복잡해진다.

이렇게 코드소유권을 느슨하게 정하는 방식은 여러 팀으로 구성된 조직에도 적용할 수 있다. 어떤팀은 다른팀 사람이 자기팀 코드의 브랜치를 따서 수정하고, 커밋을 요청하는 `오픈소스 개발 모델`을 권장하기도 한다. 이렇게하면 함수의 클라이언트도 바꿀 수 있고, 변경사항을 클라이언트의 관리자가 확인후 적용시킬 수 있다. 

이 방식은 코드소유권을 엄격하게 제한하는 방식과 완전히 풀어서 변경을 통제하기 어려운 방식을 절충한 것으로, 대규모 시스템 개발 시 잘어울린다.

### 브랜치

기능별로 브랜치를 만들어 구현해 둔뒤, 프로덕션 버전으로 릴리즈 할때 마스터로 통합하는 방식

[**장점]**

- 작업이 끊나지 않은 코드가 마스터에 섞이지 않는다
- 기능이 추가될 때마다 버전을 명확히 나눌수 있다
- 기능에 문제가 생기면 이전상태로 쉽게 되돌릴 수 있다

[**단점]**

- 독립브랜치로 작업하는 기간이 길어질수록 마스터로 통합이 어려워진다
- 이를 쉽게하기위해 마스터를 개인브랜치로 자주 rebase나 merge하지만 여러브랜치에서 작업중인경우 마지막에 코드를 합치기가 어려워진다

[**해결방안]**

- 통합 주기를 2-3일 단위로 짧게 가진다(지속적 통합, CI)
- CI + 리팩터링 = XP(Extreme Programming)

### 테스팅

- 리팩터링의 특성은 프로그램의 겉보기 동작이 똑같이 유지된다는 것이다. 동작이 깨지지 않아야 한다
- 중간에 오류가 발생하더라도, 원인이 될만한 코드의 범위가 넓지 않고, 버전관리 시스템을 이용하여 최근의 코드로 되돌릴수도 있다
- 핵심은 오류를 재빨리 잡는것이다. 이를위해 코드의 다양한 측면을 빠르게 테스트 할 수 있는 `test suite`가 필요하다
- 자가테스트를 갖추기에 노력은 많이 들지만, 효과는 상당하다. 리팩터링 뿐만 아니라 새 기능을 안전하게 추가하는데도 도움을 준다
- 버그가 생길수 있다는 불안감을 해소할 수 있다.
- 뛰어난 리팩터링 기능을 제공하는 환경(IDE)에서 제한적인 리팩토링을 안전하게 할 수도 있다

### 레거시 코드

- 오래되고, 복잡하고, 다른사람이 작성한, 테스트코드가 없는 레거시 코드는 리팩토링하기 어렵다
- 그렇기 때문에 처음부터 테스트케이스를 마련하는것이 미래에도 도움이된다

[**해결방안]**

- 프로그램에서 테스트 할 틈새를 찾아 시스템을 테스트한다
- 하나씩 공략하며 조금씩 개선해 나간다

### 데이터베이스

- 진화형 데이터베이스 설계
- 데이터베이스 리팩터링 기법

커다란 변경을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근코드와 데이터베이스 스키마에 대한 구조적 변경을 스크립트로 처리하여 통합한다.

- 마이그레이션 스크립트를 작성후, 버전관리 시스템에 저장, 이후 DB를 이전할 때마다 모여있는 스크립트를 실행시킨다.
- 데이터베이스 리팩터링은 프로덕션 환경에 여러단계로 나눠서 릴리즈 하는게 대체로 좋다는 점에서 다른 리팩터링과 다르다

[**예시: 필드 이름을 변경하는 경우]**

1. 필드 추가
2. 기존필드와 새필드 동시에 업데이트 하도록 수정
3. 새필드를 읽도록 코드를 조금씩 수정
4. 모두 교체후, 기존필드 제거

이러한 방식을 `병렬수정(또는 팽창수축)` 이라고 한다

## 6. 리팩터링, 아키텍처, 애그니(YAGNI)

리팩터링이 없다면 첫 설계부터 아키텍처를 완벽하게 설계해야 한다. 이러면 대표적인 문제로 소프트웨어 요구사항을 사전에 모두 파악해야 한다. 하지만 막상 코딩을 해보면 실현할 수 없는 목표일 때가 많다. 우리는 소프트웨어를 실제로 사용해보고 업무에 미치는 영향을 직접 확인하고 나서야 정말로 원하는 바를 알게 되는 경우가 많다.

리팩터링을 활용하면 다르게 접근할 수 있다. 앞으로 어느 부분에 유연성이 필요하고 어떻게 해야 그 변화에 가장 잘 대응할 수 있을지 추측하지 않고, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다. 단, 이 요구를 멋지게 해결하도록 설계한다. 진행하면서 사용자의 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링해서 바꾼다.

이런 식으로 설계하는 방식을 간결한 설계(simple design), 점진적 설계(incremental design), YAGNI(애그니)(”You aren’t going to need it”(필요없을 거다)의 줄임말(당장에 필요한 기능만으로 최대한 간결하게 만들라)) 등으로 부른다. 물론 YAGNI를 받아들인다고 해서 선제적인 아키텍처에 완전히 소홀해도 된다는 뜻이 아니다.

## 7. 리팩터링과 소프트웨어 개발 프로세스

리팩터링이 퍼지기 시작한 것은 익스트림 프로그래밍(XP)에 도입됐기 때문이었다. XP의 두드러진 특징은 지속적 통합(CI), 자가 테스트 코드, 리팩터링 등의 개성이 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스라는 점이다. 참고로 자가 테스트 코드와 리팩터링을 묶어서 Test Driven Development(TDD)라 한다.

리팩터링의 첫 번째 토대는 자가 테스트 코드다. 다시 말해 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행할 수 있어야 한다. **테스트는 리팩터링에 굉장히 중요한 토대이다**!!

팀으로 개발하면서 리팩터링을 하려면 각 팀원이 다른 사람의 작업을 방해하지 않으면서 언제든지 리팩터링 할 수 있어야 한다. CI를 적극 권장하는 이유도 바로 이 때문이다. CI를 적용하면 리팩터링한 결과가 다른 팀원의 작업에 문제를 일으키면 즉시 알아낼 수 있다. 자가 테스트 코드 역시 CI의 핵심 요소다. 따라서 자가 테스트 코드, CI, 리팩터링이라는 세 기법은 서로 강력한 상승효과를 발휘한다.

이상의 세 실천법을 적용한다면 앞 절에서 설명한 YAGNI 설계 방식으로 개발을 진행할 수 있다. 리팩터링과 YAGNI는 서로 긍정적인 영향을 준다. 리팩터링(과 그 선수 조건들)이 YAGNI의 토대인 동시에, YAGNI로 인해 리팩터링을 더욱 쉽게 할 수 있다.

## 8. 리팩터링과 성능

리팩터링하면 프로그램 성능이 느려질까봐 걱정하는 사람이 많다. ‘직관적인 설계 vs. 성능’은 중요한 주제다.

리팩터링하면 소프트웨어가 느려질 수도 있는 건 사실이다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다. 하드 리얼타임(hard real-time) 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은, 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다.

성능에 대한 흥미로운 사실은, 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다는 것이다. 그래서 코드 전체를 고르게 최적화한다면 그중 90%는 효과가 거의 없기 때문에 시간 낭비인 셈이다.

위 ‘90%의 시간은 낭비’라는 통계에 착안해 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경쓰지 않고 코드를 다루기 쉽게 만드는 데 집중한다. 그러다 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝한다.

1. 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다. 그러면 성능에 큰 영향을 주는 작은 부분들을 찾을 수 있다.
2. 위에서 찾은 부분들을 개선한다. 이때도 물론 신중하게 작업해야한다. 리팩터링할 때처럼 최적화를 위한 수정도 작은 단계로 나눠서 진행한다. 각 단계마다 컴파일과 테스트를 거치고 프로파일러를 다시 실행해본다. 성능이 개선되지 않았다면 수정 내용을 되돌린다.
3. 위 절차를 사용자가 만족하는 성능에 도달할 때까지 진행한다.

프로그램을 잘 리팩터링해두면 이런 식의 최적화에 두 가지 면에서 도움이 된다.

1. 성능 튜닝에 투입할 시간을 벌 수 있다. 리팩터링이 잘 돼 있다면 기능 추가가 빨리 끝나 성능에 집중할 시간을 더 벌 수 있다.
2. 리팩터링이 잘 돼 있는 프로그램은 성능을 더 세밀하게 분석할 수 있다. 프로파일러가 지적해주는 코드의 범위가 더 좁아질 것이고, 그래서 튜닝하기 쉬워진다. 코드가 깔끔하면 개선안들이 더 잘 떠오를 것이고, 그중 어떤 튜닝이 효과가 좋을지 파악하기 쉽다.

리팩터링은 성능 좋은 소프트웨어를 만드는 데 기여한다. 단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수도 있다. 하지만 최적화 단계에서 코드를 튜닝하기 훨씬 쉬워지기 때문에 결국 더 빠른 소프트웨어를 얻게 된다.

## 9. 리팩터링의 유래

## 10. 리팩터링 자동화

요새 IDE(ex: IntelliJ IDEA, Eclipse, Visual Studio) 또는 에디터(ex: Visual Studio Code)는 자동으로 리팩터링 해주는 기능을 지원한다.

리팩터링을 자동화하는 가장 어설픈 방법은 소스 코드의 텍스트를 직접 조작하는 것이다. 이 방식은 허점이 많기 때문에 테스트해보기 전에는 결과를 신뢰해서는 안 된다. 하지만 리팩터링에 첫 발을 딛는 데는 유용하다.

자동 리팩터링을 제대로 구현하려면 코드를 텍스트 상태가 아닌, 구문 트리(Syntax Tree)로 해석해서 다뤄야 한다. 구문 트리를 조작하는 방식이 코드의 원래 의미를 보존하는 데 훨씬 유리하기 때문이다. 그래서 뛰어난 IDE가 자동 리팩터링도 더 풍부하게 제공하는 경우가 많다.

최근에는 Language Server Protocol(LSP)이라는 기술이 뜨고 있다. LSP란 구문 트리를 구성해 텍스트 에디터에 API 형태로 제공하는 소프트웨어다. LSP는 다양한 텍스트 에디터를 지원할 수 있고, 정교한 코드 분석과 리팩터링 기능을 제공할 수 있다.

## 11. 더 알고 싶다면

리팩터링 연습에 주력한 책을 원한다면 월리엄 웨이크(William C. Wake)가 쓴 “리팩터링 워크북”(인사이트, 2006)을 추천한다.

조슈아 케리에프스카(Joshua Kerievsky)가 쓴 “패턴을 활용한 리팩터링”(인사이트, 2011)은 소프트웨어 패턴 분야에 지대한 영향을 준 “디자인 패턴” 책 중에서 가장 핵심적인 패턴을 골라, 코드를 그 패턴대로 재구성하기 위해 리팩터링하는 방법을 다룬다.

특정 분야에 특화된 리팩터링 책에 대표적인 예로는 다음이 있다. 스캇 엠블러(Scott Ambler)와 프라모드 사달게(Pramod Sadalage)의 “리팩토링 데이터베이스”(위키북스, 2007)과 엘리엇 러스티 해롤드(Elliotte Rusty Harold)의 “리팩토링 HTML”(에이콘출판사, 2009)이 있다.

테스트 커버리지가 낮은 오래된 코드베이스를 리팩터링하는 방법을 다루는 “레거시 코드 활용 전략”(에이콘출판사, 2018)이 있다.

최신 자료를 보고 싶다면 이 책의 깃허브 지원 페이지([https://github.com/WegraLee/Refactoring](https://github.com/WegraLee/Refactoring))와 리팩터링 웹사이트([https://refactoring.com/](https://refactoring.com/))을 참고하라.
# 코드에서 나는 악취

리펙터링 적용 방법을 `아는 것`과 `때에 맞게 적용할 줄 아는 것`은 다르다. 리펙터링을 언제 시작하고 그만할지 판단하는 일은 리펙터링의 원리를 아는 것 못지않게 중요하다.

작자의 경험에 따르면 숙련된 사람의 직관만큼 정확한 것이 없었고 그만큼 각자의 경험을 통해 리펙터링을 적용할 때에 대한 감을 키워나갈 것을 권함.

작자는 켄트 벡과 함께 리펙터링이 필요한 코드에 일정한 패턴이 있다는 사실을 발견하였고 리펙터링을 언제 멈춰야하는지에 대한 기준보다는 리펙터링을 하면 해결할 수 있는 문제의 징후를 다음 항목들로 정리하였다. 

## 1. 기이한 이름

코드를 정리하는데 있어 가장 중요한 요소 중 하나는 `이름 짓기`다. 코드는 단순하고 명료하게 작성해야한다.

함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하는지, 어떻게 사용해야 하는지 명확히 알 수 있도록 신경써야한다. 

이름만 잘 지어도 나중에 문맥을 파악하는데 해매는 시간을 크게 절약할 수 있다.

이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아닌 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높기에 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 함수 선언 바꾸기 *(6. 5절)*
2. 변수 이름 바꾸기 *(6. 7절)*
3. 필드 이름 바꾸기 *(9. 2절)*

## 2. 중복코드

코드가 중복되면 각각을 볼 때 마다 서로 차이점은 없는지 살펴야하고 그 중 하나를 변경할 시에는 다른 비슷한 모든 코드를 검수해야하는 부담이 생기게 되기 떄문이다.

똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다. 
아래의 리펙터링 기법을 적용하여 반복되는 구조를 최소화 하는 것이 바람직하다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 함수 추출하기 *(6. 1절)*
2. 문장 슬라이드하기 *(8. 6절)*
3. 메서드 올리기 *(12. 1절)*

## 3. 긴 함수

오랜 기간 잘 활용되는 프로그램들은 하나같이 `짧은 함수`들로 구성되어 있다. 
이런 프로그램의 코드베이스를 보면 연산하는 부분이 하나도 없어 보이나 이는 코드가 끝없이 위임하는 방식으로 되어 있기 때문이다. 코드를 이해하고, 공유하고 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 오는 것이다. 

코드를 읽는 사람 입장에서 함수가 하는 일을 파악하기 위해 오가는 부담은 존재하나 함수의 호출부와 선언부를 빠르게 이동하거나 선언과 호출을 동시에 보여주는 개발 환경을 활용하는 방법으로 부담을 덜기도 하나 가장 좋은 방법은 `좋은 이름`이다. 

이를 위해서 우리는 적극적으로 함수를 쪼개야한다.  주석을 달아야 할 만한 부분은 무조건 함수로 만들고 그 함수의 본문에는 원래 주석으로 설명하려던 코드가 담기고 함수 이름은 `동작 방식`이 아닌 `의도`가 들어나게 짓는다. 

핵심은 함수의 길이가 아닌 함수의 목적과 구현 코드간의 괴리가 얼마나 큰가 다. 즉 무엇을 하는지를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 함수 추출하기 *(6. 1절)*
2. 임시 변수를 질의 함수로 바꾸기 *(7. 4절)*
3. 매개변수 객체 만들기 *(6. 8절)*
4. 객체 통째로 넘기기 *(11. 4절)*
5. 함수를 명령으로 넘기기 *(11. 9절)*
6. 조건문 분해하기 *(10. 1절)*
7. 조건부 로직을 다형성으로 바꾸기 *(10. 4절)*
8. 반복문 쪼개기 *(8. 7절)*

## 4. 긴 매개변수 목록

예전에는 함수에 필요한 것들을 모조리 매개변수로 전달하였다. 그래야 전역 데이터가 늘어나는 사태를 막을 수 있기 때문에 그 시절에는 합리적 방식이였다.

하지만 매개변수 목록이 길어지면 그 자체로 이해하기 어려운 때가 많다.

아래의 리펙터링 기법을 적용해 매개변수를 줄이는 것이 바람직하다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 매개변수를 질의 함수로 바꾸기 *(11. 5절)*
2. 객체를 통째로 넘기기 *(11. 4절)*
3. 매개변수 객체 만들기 *(6. 8절)*
4. 플래그 인수 제거하기 *(11. 3절)*
5. 여러 함수를 클래스로 묶기 *(6. 9절)*

## 5. 전역 데이터

`전역 데이터`는 가장 안좋은 징후 중 하나이다. 코드베이스 어디에서든 건들 수 있고 누가 값을 바꿨는지 찾아낼 매커니즘이 없다는게 그 이유다. 

이 경우 버그가 발생해도 그 원인을 찾아내기 굉장히 어렵다.

이를 방지하기 위한 대표적 리펙터링은 `변수 캡슐화` 다. 
다른 코드에서 오염시킬 가능성이 있는 데이터를 발결할 때마다 이 기법을 먼저 적용하면 이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 `특정`하고 접근을 `통제`할 수 있게 된다.

접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 변수 캡슐화하기 *(6. 6절)*

## 6. 가변 데이터

데이터를 변경하는 것이 골치아픈 버그로 이어지는 경우가 종종 있다. 특히나 드문 조건에서만 이 문제가 발생한다면 원인을 알아내기 힘들기에 함수형 프로그래밍에서는 데이터는 절대 변하지 않고 데이터를 변경하려면 반드시 변경하려는 값에 해당하는 복사본을 만들어 변환한다는 개념을 기본을 삼는다.

하지만 함수형 언어가 프로그래밍에서 차지하는 비중은 여전히 적고 변수 값을 바꿀 수 있는 언어를 사용하는 프로그래머가 더 많다.

무분별한 데이터 수정에 따른 위험을 줄이는 방법은 `변수 캡술화` 를 통해 통제하고, 변수를 쪼개거나 갱신 로직을 다른 코드와 떨어뜨려 놓는 등으로 변수의 유효 범위를 줄이면 된다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 변수 캡슐화하기 *(6. 6절)*
2. 변수 쪼개기 *(9. 1절)*
3. 문장 슬라이드하기 *(8. 6절)*
4. 함수 추출하기 *(6. 1절)*
5. 질의 함수와 변경 함수 분리하기 *(11. 1절)*
6. 세터 제거하기 *(11. 7절)*
7. 파생 변수를 질의 변수로 바꾸기 *(9. 3절)*
8. 여러 함수를 클래스로 묶기 *(6. 9절)*
9. 여러 함수를 변환 함수로 묶기 *(6. 10절)*
10. 참조를 값으로 바꾸기 *(9. 4절)*

## 7. 뒤엉킨 변경

`단일 책임 원칙`이 제대로 지켜지지 않을 때 나타난다. 즉 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.

예를 들어 지원해야할 데이터 베이스가 추가될 때마다 함수 세 개를 바꿔야하고 금융 상품이 추가될 때 마다 또 다른 함수 4개를 바꿔야하는 모듈이 있다면 `뒤엉킨 변경`이 발생한 것이다.

위의 예시에서 데이터 베이스 연동과 금융 상품 처리는 서로 다른 맥락에서 이뤄지므로 독립된 모듈로 분리하는 것이 좋다.

즉 처리 과정을 맥락별로 분리하는 것이 바람직하다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 단계 쪼개기 *(6. 11절)*
2. 함수 옮기기 *(8. 1절)*
3. 함수 추출하기 *(6. 1절)*
4. 클래스 추출하기 *(7. 3절)*

## 8. 산탄총 수술

7번과 비슷하지만 반대의 경우로 이는 코드를 변경할 때마다 자잘하게 수정해야하는 클래스가 많을 때를 말한다. 변경할 부분이 코드 전반에 퍼저있다면 찾기도 힘들고 수정할 곳을 지나치기 쉽다.

이 상황에서는 함께 변경되는 대상들을 한 모듈에 묶어두면 좋다.
비슷한 데이터를 다루는 함수가 많다면 여러 함수를 클래스로 데이터를 변환하거나 보강하는 함수들에는 변환 함수로 묶는다. 

어설프게 분리된 로직을 인라인 리펙터링으로 하나로 합치는 것도 산탕총 수술에 대처하는 좋은 방법이다. 
메서드나 클래스가 비대해지지만 나중에 추출하기 리펙터링으로 더 좋은 형태로 분리할 수 있다.

처리 과정을 맥락별로 모으는 것이 바람직하다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 함수 옮기기 *(8. 1절)*
2. 필드 옮기기 *(8. 2절)*
3. 여러 함수를 클래스로 묶기 *(6. 9절)*
4. 여러 함수를 변환 함수로 묶기 *(6. 10절)*
5. 단계 쪼개기 *(6. 11절)*

## 9. 기능 편애

`프로그램의 모듈화`에는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역간의 상호작용은 최소로 줄이는 데 주력한다. 기능 편얘는 흔히 자기가 속한 영역의 함수나 데이터보다 다른 영역의 함수나 데이터간의 상호작용이 많을 때를 말한다. 
이 경우 더 많은 상호작용이 일어난 영역으로 해당 함수를 욺기면 된다.

함수가 사용하는 모듈이 다양하여 마땅히 욺길 영역을 특정할 수 없다면 그 함수를 쪼개 각각을 적합한 모듈로 옮기면 더 쉽게 해결되는 경우가 있다.

위에서 말한 경우로 해결되지 않는 경우 또한 존재하는데 디자인 패턴 중 `전략 패턴` , `방문자 패턴`이 그 예이다.
이는 `뒤엉킨 변경`을 해결하는데 사용하는 패턴으로 기본 원칙은 함꼐 변경할 대상을 한데 모으는 것이다. 데이터와 이를 활용하는 동작은 함께 변경해야 할 때가 많지만 예외가 있다. 그때는 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 옮긴다.
`전략 패턴`과 `방문자 패턴`을 적용하면 소량의 동작 코드를 각각의 클래스로 격리해주어 수정하기 쉬워진다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 함수 옮기기 *(8. 1절)*
2. 함수 추출하기 *(6. 1절)*

## 10. 데이터 뭉치

데이터 항목이 서너 개가 여러곳에서 뭉쳐 다니는 모습을 흔히 볼 수 있는데 이 `데이터 뭉치`라 하고 정리하는 것이 좋다.

데이터 뭉치인지 판별은 값을 하나 삭제해보아 나머지 데이터만으로 의미가 없다면 데이터 뭉치인 것이다.

필드 형태의 데이터 뭉치를 클래스 추출하기로 하나의 객체로 묶고 다음 메서드 시그니처에 있는 데이터 뭉치는 `매개변수를 줄이는 리펙터링` 을 통하면 메서드 호출 코드가 간결해질 것이다.
데이터 뭉치가 앞에서 만든 객체 필드 중 일부만 사용하더라도 걱정할 필요는 없다. 새 객체로 뽑아낸 필드가 두 개 이상이기만 해도 확실히 이전에 비해 개선되어 있을 것이다.

클래스로 만들기를 권하는 이유는 간단한 레코드 구조가 아닌 클래스로 만든다면 좋은 기회가 많아지기 때문이다.

기능 편얘를 없애는 과정에서 새롭게 클래스를 만들었다면 그 클래스로 욺기면 좋은 동작은 없는지 고민해보자. 
이러한 연계 과정은 상당한 중복을 없애고 향후 개발을 가속하는 유용한 클래스로 탄생되곤 한다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 클래스 추출하기 *(7. 3절)*
2. 매개변수 객체 만들기 *(6. 8절)*
3. 객체 통째로 넘기기 *(11. 4절)*

## 11. 기본형 집착

대부분의 프로그래밍 언어는 다양한 기본형을 제공하는데 라이브러리를 통해 날짜와 같은 간단한 객체를 추가로 제공하고는 한다. 
프로그래머 중에는 자신에게 주어진 문제에 딱 맞는 기초 타입(좌표, 화폐)등 을 직접 정의하기 꺼리는 사람들이 많다. 그래서 금액을 그냥 숫자형으로 계산하거나 물리량을 계산할 때 밀리미터나 인치 같은 단위를 무시하는 경우가 많다. 특히나 문자열을 다루는 코드에서 흔한데 전화번호를 예로 단순한 문자 집합으로만 표현하는 등의 아쉬움이 있다.
이런 경우는 너무나도 흔해 `문자열화된 변수`라는 이름까지 붙었다.

기본형을 객체로 바꾸기를 적용하면 좋은 코드로 바꿀 수 있다.

기본형으로 표현된 코드가 조건부 동작을 제어하는 타입코드로 쓰였다면 `타입코드를 서브 클래스`로 바꾸거나 `조건부 로직을 다형성으로 바꾸기` 를 차례로 적용한다.

자주 함께 몰려다니는 기본형 그룹도 `데이터 뭉치`로 볼 수 있는데 따라서 `클래스 추출하기`와 `매개변수를 줄히는 리펙터링`을 통해 리펙터링하는 것을 권한다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 기본형을 객체로 바꾸기 *(7. 3절)*
2. 타입 코드를 서브클래스로 바꾸기 *(12. 6절)*
3. 조건부 로직을 다형성으로 바꾸기 *(10. 4절)*
4. 클래스 추출하기 *(7. 5절)*
5. 매개변수 객체 만들기 *(6. 8절)*

## 12. 반복되는 switch문

스위치문을 모두 조건부 로직을 다형성으로 바꾸기를 적용하여 없애야 할 대상으로 보는 시각이 있었다.
다형성이란 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미한다.

과거와 달리 스위치문을 썼다고 해서 자동으로 검토 대상이 되는 시대는 지났고 문자열 등 더 복잡한 타입을 지원하는 발전된 스위치문을 제공하는 언어도 많아졌다. 그러니 이제는 똑같은 조건부 로직이 여러 곳에서 반복적으로 나타나는 코드에 집중하자. 
중복된 스위치 문이 문제가 되는 것은 조건 하나를 추가할 때 마다 다른 스위치문들도 모두 찾아
수정해야하기 떄문이다.

다형성은 이를 해소해 코드를 최신 스타일로 바꿔주는 도구다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 조건부 로직을 다형성으로 바꾸기 *(10. 4절)*

## 13. 반복문

반복문은 프로그래밍 언어가 등장할 때부터 함께 한 핵심 프로그래밍 요소이나 지금은 일급 함수를 지원하는 언어가 많아졌기에 `반복문을 파이프라인으로 바꾸기` 를 적용해 시대에 맞지 않는 반복문을 제거할 수 있게 됐다. 

파이프라인 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 반복문을 파이프라인으로 바꾸기 *(8. 8절)*

## 14. 성의 없는 요소

우리는 코드의 구조를 잡을 때 프로그램 요소를 이용하는 것을 좋아한다. 그래야 그 구조를 변형하거나 재활용할 기회가 생기고 혹은 단순히 더 의미있는 이름을 가졌기 때문인데 그렇지만 그 구조가 필요하지 않을 때도 있다.

예로 본문 코드를 그대로 쓰는 것과 다름없는 함수나 실질적으로 메소드가 하나뿐인 클래스도 있다. 이런 구조는 어떤 이유로 만들어졌건 없애는 것이 좋다.

흔히 `함수 인라인하기`, `클래스 인라인하기`, 상속을 이용했다면 `계층 합치기` 를 적용한다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 함수 인라인하기 *(6. 2절)*
2. 클래스 인라인하기 *(7. 6절)*
3. 계층 합치기 *(12. 9절)*

## 15. 추측성 일반화

`추측성 일반화`는 나중에 필요할 거라는 생각으로 당장에 필요없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드를 말한다. 결과 이 코드는 이해하기 어렵고 관리하기 힘든 코드다.

하는 일이 없는 추상 클래스는 `계층합치기` 로 제거하고 쓸데없는 위임을 하는 코드는 `함수 인라인하기`, `클래스 인라인하기`로 처리한다. 본문에서 사용하지 않는 매개변수는 `함수 선언 바꾸기`로 없앤다.

이런 코드는 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔히 볼 수 있는데 이런 코드를 발견하면 테스트 케이스부터 삭제한 뒤 `죽은 코드제거하기`로 제거하자.

미래를 대비해 작성한 부분을 사용하게 된다면 다행이지만
그렇지 않는다면 낭비일 뿐으로 당장 걸리적거리는 코드는 눈앞에서 치우는 것이 바람직하다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 계층 합치기 *(12. 9절)* 
2. 함수 인라인하기 *(6. 2절)*
3. 클래스 인라인하기 *(7. 6절)*
4. 함수 선언 바꾸기 *(6. 5절)*
5. 죽은 코드 제거하기 *(8. 9절)*

## 16. 임시 필드

객체를 가져올 때는 당연히 모든 필드가 채워져 있을 거라고 기대하는 것이 보통이므로 특정 상황에서만 값이 설정되는 임시 필드를 사용하게 되면 코드를 이해하기 어려워진다. 

이런 필드를 발견하면 `클래스 추출하기`를 적용한 다음 `함수 옮기기`를 통해 임시 필드와 관련된 모든 코드를 새 클래스에 몰아 넣는다. 

또한 임시 필드들이 유효한지 확인한 후 동작하는 로직이 있을 수 있는데 `특이 케이스 추가하기` 로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어 제거할 수 있다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 클래스 추출하기 *(7. 5절)*
2. 함수 옮기기 *(8. 1절)*
3. 특이 케이스 추가하기 *(10. 5절)*

## 17. 메시지 체인

메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.

게터가 꼬리에 꼬리를 물고 이어지거나 임시 변수들이 줄줄이 나열되는 코드가 있다면 이는 클라이언트가 객체 내비게이션 구조에 종속되었음을 의미하며 내비게이션 중간 단계를 수정하려면 클라이언트 구조도 수정해야한다.

이 문제는 `위임 숨기기` 로 해결한다. 이 기법은 메시지 체인의 다양한 연결점에 적용할 수 있다. 
원칙적으로 체인을 구성하는 모든 객체에 적용할 수 있지만 그러다보면 중간 객체들이 `중개자`가 되어버리기 쉽상이다. 그러니 최종 결과 객체가 어떻게 쓰이는지부터 살펴보는 것이 좋다.
`함수 추출하기` 로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음 `함수 옮기기` 로 체인을 숨길 수 있는지 살펴보자. 체인을 구성하는 객체 중 특정 하나를 사용하는 클라이언트 중 그 이후의 객체들도 사용하길 원하는 클라이언트가 제법 된다면 이 요구를 처리해줄 메서드를 추가한다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 위임 숨기기 *(7. 7절)*
2. 함수 추출하기 *(6. 1절)*
3. 함수 옮기기 *(8. 1절)*

## 18. 중개자

객체의 대표적인 기능 하나로 외부로부터 세부사항을 숨겨주는 캡슐화가 있다. 이 과정에는 위임이 자주 활용되는데 이가 지나치게되면 문제가 되곤 한다.

클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있는 등의 상황에는 `중개자 제거하기`를 활용해 실제로 일을 하는 객체와 직접 소통하도록 바꾸고 위임 메서드가 남는 일이 거의 없다면 호출하는 쪽으로 `함수 인라인하기` 를 적용하자.

### 해당 징후 시에 적용할 리펙터링 기법

1. 중개자 제거하기 *(7. 8절)*
2. 함수 인라인하기 *(6. 2절)*

## 19. 내부자 거래

모듈 사이의 데이터 거래가 많으면 결합도가 높다고 하는데 바람직한 형태는 아니다.

일을 돌아가게 하려면 거래가 이뤄질 수 밖에 없지만 그 양을 최소로 줄이고 모두 투명하게 처리하는 것이 좋다. 

데이터를 주고 받는 모듈이 있다면 `함수 옮기기`, `필드 옮기기` 기법으로 떼어놓아 사적으로 처리하는 부분을 줄이고 여러 모듈이 같은 부분을 공유한다면 공통 부분을 정식으로 처리하는 제 3의 모듈을 새로 만드거나 위임 숨기기를 이용하여 다른 모듈이 중간자 역할을 하게 만든다.

상속 구조에서는 자식 클래스는 부모 클래스가 공개하고 싶은 것 이상으로 부모에 대해 알려고 하는데 그러다가 부모 품을 떠나야할 때가 온다면 `서브클래스를 위임으로 바꾸기`, `슈퍼클래스를 위임`으로 바꾸기를 활용하자.

### 해당 징후 시에 적용할 리펙터링 기법

## 20. 거대한 클래스

한 클래스가 너무 많은 일을 하려하다 보면 필드 수가 상당히 늘어나고 클래스에 필드가 너무 많으면 중복의 가능성이 커진다.

이럴 경우 클래스 추출하기로 필드 일부를 따로 묶는다. 같은 컴포넌트에 모아두는 것이 합당해 보이는 필드들을 선택하면 된다. 분리한 컴포넌트를 `클래스 추출`하기 보다 원래 클래스와 상속 관계로 만드는 것이 좋다면 `슈퍼클래스 추출하기` 나 `타입 코드를 서브클래스로 바꾸기`(실질적으로 서브클래스 추출하기)를 적용하는 편이 쉽다. 

필드가 많은 클래스와 마찬가지로 코드량이 너무 많은 클래스도 동일한 선상에 있는데 가장 간단한 방법은 그 클래스 안에서 자체적으로 중복을 제거하는 것이 좋다.

클라이언트들이 거대 클래스를 이용하는지 패턴을 파악하여 클래스를 어떻게 쪼갤지 단서를 얻을 수 있는데 해당 클래스의 특정 기능 그룹만 주로 사용하는지 살핀다.
이때 각각의 기능 그룹이 개별 클래스로 추출될 후부로 위에 상술된 리펙터링 기법을 마찬가지로 활용해서 여러 클래스로 분리한다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 클래스 추출하기 *(7. 3절)*
2. 슈퍼클래스 추출하기 *(12. 8절)*
3. 타입 코드를 서브클래스로 바꾸기 *(12. 6절)*

## 21. 서로 다른 인터페이스의 대안 클래스들

클래스를 사용할 때 가장 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 점이다.

단 교체하려면 인터페이스가 같아야하는데 따라서 `함수 선언 바꾸기`로 메서드 시그니처를 일치시킨다. 때때로 이것만으로 부족할 시엔 `함수 옮기기` 를 이용하여 인터페이스가 같아질 때 까지 필요한 동작을 클래스 안으로 밀어 넣는다. 
그러다 대안 클래스들 사이에 중복 코드가 생기면 `슈퍼클래스 추출하기` 를 적용할 지 고려해본다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 함수 선언 바꾸기 *(6. 5절)*
2. 함수 옮기기 *(8. 1절)*
3. 슈퍼클래스 추출하기 *(12. 8절)*

## 22. 데이터 클래스

데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말하는데 그저 데이터의 저장 용도로만 쓰이니 다른 클래스가 너무 깊이까지 다룰 때가 많다. 이런 클래스에 public 필드가 있다면 `레코드 캡슐화하기` 로 숨기자. 변경하면 안 되는 필드는 `세터 제거하기` 로 접근 자체를 봉쇄한다.

다른 클래스에서 데이터 클래스의 게터나 세터를 사용하는 메서드를 찾아서 `함수 옮기기` 로 그 메서드를 데이터 클래스로 옮길 수 있는지 보자. 메서드를 통째로 옮기기 힘들다면  `함수 추출하기` 를 이용하여 옮길 수 있는 부분만 별도 메서드로 뽑아내자. 

한편으론 데이터 클래스는 필요한 동작이 엉뚱한 곳에 있다는 신호일 수 있다. 이런 경우 클라이언트 코드를 데이터 클래스로 옮기기만해도 대폭 개선된다. 예외도 있는데 특히 다른 함수를 호출해 얻은 결과 레코드로는 동작 코드를 넣을 이유가 없다. 대포적인 예로 `단계 쪼개기`의 결과로 나온 중간 데이터 구조가 있다. 이런 데이터 구조는 `불변`이다. 불변 필드는 굳이 캡슐화할 필요가 없고 그로 부터 나오는 정보는 게터를 통하지 않고 그냥 필드를 공개해도 무방하다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 레코드 캡슐화하기 *(7 .1절)*
2. 세터 제거하기 *(11. 7절)*
3. 함수 옮기기 *(8. 1절)*
4. 함수 추출하기 *(6. 1절)*

## 23. 상속 포기

서브 클래스는 부모로부터 메서드와 데이터를 물려받는데 부모의 유산을 원치 않거나 필요없다면 먼저 같은 계층에 서브클래스를 하나 만들고,  `메서드 내리기` 와 `필드 내리기` 를 활용해서 물려받지 않을 부모 코드를 모조리 새로 만든 서브 클래스로 넘긴다. 그러면 부모에는 공통된 부분만 남는다.

하지만 실무 관점에서 일부 동작의 재활용을 위한 목적으로 상속을 활용하는 것은 유용한 방법이다. 바람직한 방식은 아니지만 틀린 방법은 아니고 어느정도 융통성을 발휘해도 되는 부분이다.

특히 상속 포기에서 살펴야할 부분은 서브클래스가 부모의 동작을 필요로하나 인터페이스는 따르고 싶지 않을 때이다. 이럴 경우 `서브 클래스를 위임으로 바꾸기`, `슈퍼 클래스를 위임으로 바꾸기` 를 활용해서 아예 상속 매커니즘을 벗어나자.

### 해당 징후 시에 적용할 리펙터링 기법

1. 메서드 내리기 *(12. 4절)*
2. 필드 내리기 *(12. 5절)*
3. 서브 클래스를 위임으로 바꾸기 *(12. 10절)*
4. 슈퍼 클래스를 위임으로 바꾸기 *(12. 11절)*

## 24. 주석

주석을 다는 것은 권장되는 바람직한 행동이지만 코드에 주석이 장황하게 달린 경우 코드를 잘 못 작성했기 때문인 경우가 의외로 많다.

주석이 많으면 이 장에서 소개한 온갖 징후를 나타내는 코드가 나오기 쉽다. 실제로 리펙터링 후 상당량의 주석이 군더더기인 적이 많았다고 한다.

특정 코드 블럭이 하는 일에 주석을 남기고 싶다면 `함수 추출하기` 를 적용해보고 그럼에도 설명이 필요하다면 `함수 선언 바꾸기` 로 함수 이름을 바꿔본다. 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 `어서션 추가하기` 가 기다리고 있다.

‘주석을 남겨야 겠다는 생각이 들면, 가장 먼저 주석이 필요없는 코드로 리펙터링해본다.’

하지만 뭘 할지 모를 때라면 주석을 달아두는 것이 바람직하다. 현재 진행 상황뿐 아니라 확실하지 않은 부분에도, 코드를 지금처럼 작성한 이유를 설명하는 용도로도 사용할 수 있다. 이런 정보는 본인을 포함한 읽는 자로 하여금 많은 도움이 될 것이다.

### 해당 징후 시에 적용할 리펙터링 기법

1. 함수 추출하기 *(6. 1절)*
2. 함수 선언 바꾸기 *(6. 5절)*
3. 어서션 추가하기 *(10. 6절)*
